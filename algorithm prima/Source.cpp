#include <stdio.h>
#include <limits.h>
#include<stdbool.h>
#define V 7

// Функция поиска минимального веса ребра
int minKey(int key[], bool mstSet[])
{
    // Инициализация: минимальный вес - беск.
    int min = INT_MAX, min_index;

    // Цикл по всем вершинам
    for (int v = 0; v < V; v++)
        // Если вершина непросмотрена и лежащий к ней вес меньше минимального
        if (mstSet[v] == false && key[v] < min)
            // Запомнить вес и его индекс
            min = key[v], min_index = v;
    return min_index;
}

//Печать веса минимального остовного дерева
int printMST(int parent[], int n, int graph[V][V])
{
    printf("Вершина \Вес ребра\n");
    // Инициализация: сумма по весу = 0
    int sum = 0;
    // Цикл по всем вершинам
    for (int i = 1; i < V; i++)
    {
        // Суммирование веса ребер оставного дерева
        sum += graph[i][parent[i]];
        // Печать веса по вершинам, путь к вершинам
        printf("%d - %d \t%d \n", parent[i], i, graph[i][parent[i]]);
    }
    // Печать веса дерева
    printf("Вес минимального остовного дерева: %d\n", sum);

}

void primMST(int graph[V][V])
{
    int parent[V];
    int key[V];
    bool mstSet[V];

    // НЕ ЦИКЛ. Инициализация массива вершин и просмотренных вершин
    for (int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    // Обнуление первых элементов массива вершин и их просмотренных
    key[0] = 0;
    parent[0] = -1;

    // Пока i меньше макс. возможного кол-ва вершин
    for (int count = 0; count < V - 1; count++)
    {
        // Запомнить наименьший вес ребра
        int u = minKey(key, mstSet);

        // Текущая вершина отмечается просмотренной
        mstSet[u] = true;

        // Цикл по всем вершинам
        for (int v = 0; v < V; v++)
            // Если вершина графа существует, непросмотренна и вес смежного с ним ребра меньше запомненного
            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])
                // Запомнить мин. индекс как вершина-родитель
                // Запомнить элемент графа по мин. индексу
                parent[v] = u, key[v] = graph[u][v];
    }

    // Печать результата
    printMST(parent, V, graph);
}

int main()
{

    // Инициализация матрицы смежности
    int graph[V][V] = { {0, 3, 0, 0, 8, 0, 0},
                        {3, 0, 2, 10, 0, 0, 0},
                        {0, 2, 0, 0, 0, 0, 0},
                        {0, 10, 0, 0, 0, 0, 1},
                        {8, 0, 0, 0, 0, 0, 1},
                        {0, 0, 0, 0, 0, 0, 9},
                        {0, 0, 0, 1, 1, 9, 0} };

    // Алгоритм Прима
    primMST(graph);

    return 0;
}